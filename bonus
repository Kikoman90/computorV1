BONUS:

* forme naturelle [YES] -> attention: bonus hors du slider 5/5

* ERROR HANDLING/PARSING -> 1 point
* FILE OPTION -> 1 point
* STEP OPTION -> 1 point
* IRREDUCIBLE FRACTIONS -> 1 point
* COLORS -> 1 point
* INTERRUPT / MULTIPLE ARGUMENTS / ...
* SWITCH FP TO DBL
* 

// equation regex match -> group 1 | group 12
// group 1 -> ((2)|(3)|(4))[whitespaces]?((5)|(10))
// group 5 -> ((6)|(7))(8(9)?)?
// group 10 -> ((11)(12)?)([*]((13)|(14)))?
_equationRegex =
	std::regex("(" // 1 : term match (a*X^d) with a = coefficient (constant) and d = degree of the indeterminate X
					"(?:"
						"(?:^\\s*([-+]?))|" // 2 : beginning of line (optional sign)
						"(?:\\s*([-+]))|" // 3 : otherwise, operator is not optional
						"(?:\\s*[=]\\s*([-+]?))" // 4 : monomial right after '=' sign is optional
					")"
					"\\s*" // ignore whitespaces
					"(?:"
						"(" // 5 : coefficient followed by optional x
							"(?:"
								"(?:"
									"(?:0+\\B)?"
									"((?:\\d+)(?:[.]\\d*)?)" // 6 : digits with optional decimals
								")|([.]\\d+)" // 7 : decimal point followed by digits
							")"
							"(\\s*[*]?\\s*[xX](?:\\s*\\^\\s*(?:0+\\B)?(\\d+))?)?"  // 8 : X part of the term (optional); 9 : the degree (optional)
						")|(" // 10: x followed by optional coefficient
							"([xX](?:\\s*\\^\\s*(?:0+\\B)?(\\d+))?)"  // 11 : X part of the term; 12 : the degree (optional)
							"(\\s*[*]\\s*" // 13 : coefficient part of the term (optional)
								"(?:"
									"(?:"
										"(?:0+\\B)?"
										"((?:\\d+)(?:[.]\\d*)?)" // 14 : digits with optional decimals
									")|([.]\\d+)" // 15 : decimal point followed by digits
								")"
							")?"
						")"
					")"
				")|(.+)"); // 16 : any other match (=invalid)

// option regex match -> -f || -s || -sf || -sf
_optionRegex = std::regex("\\s*[-](?:(s)|(f))");